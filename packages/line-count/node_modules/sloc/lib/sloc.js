// Generated by CoffeeScript 1.7.1

/*
This program is distributed under the terms of the GPLv3 license.
Copyright 2012 - 2014 (c) Markus Kohlhase <mail@markus-kohlhase.de>
 */

(function() {
  var countBlock, countComments, countMixed, emptyLines, endOfLine, getCommentExpressions, getStop, getType, keys, lineSum, newLines, nonEmptyLine, slocModule, trampoline;

  keys = ['total', 'source', 'comment', 'single', 'block', 'mixed', 'empty'];

  nonEmptyLine = /[^\s]/;

  endOfLine = /$/m;

  newLines = /\n/g;

  emptyLines = /^\s*$/mg;

  getCommentExpressions = function(lang) {
    var single, start, stop;
    single = (function() {
      switch (lang) {
        case "coffee":
        case "py":
          return /\#/;
        case "js":
        case "c":
        case "cc":
        case "cpp":
        case "h":
        case "hpp":
        case "hx":
        case "ino":
        case "java":
        case "php":
        case "php5":
        case "go":
        case "scss":
        case "less":
        case "styl":
          return /\/{2}/;
        case "lua":
          return /--/;
        case "erl":
          return /\%/;
        default:
          return null;
      }
    })();
    switch (lang) {
      case "coffee":
        start = stop = /\#{3}/;
        break;
      case "js":
      case "c":
      case "cc":
      case "cpp":
      case "h":
      case "hpp":
      case "hx":
      case "ino":
      case "java":
      case "php":
      case "php5":
      case "go":
      case "css":
      case "scss":
      case "less":
      case "styl":
        start = /\/\*+/;
        stop = /\*\/{1}/;
        break;
      case "python":
      case "py":
        start = stop = /\"{3}|\'{3}/;
        break;
      case "html":
        start = /<\!--/;
        stop = /-->/;
        break;
      case "lua":
        start = /--\[{2}/;
        stop = /--\]{2}/;
        break;
      case "erl":
        start = stop = null;
        break;
      default:
        throw new TypeError("File extension '" + lang + "' is not supported");
    }
    return {
      start: start,
      stop: stop,
      single: single
    };
  };

  countMixed = function(lines, match, idx, startIdx, res) {
    if (nonEmptyLine.exec(lines[0]) && idx !== 0) {
      res.mixed.push({
        start: idx,
        stop: idx
      });
    }
    if (nonEmptyLine.exec(lines[startIdx - idx])) {
      return res.mixed.push({
        start: startIdx,
        stop: startIdx
      });
    }
  };

  getStop = function(comment, type, regex) {
    return comment.match((function() {
      switch (type) {
        case 'single':
          return endOfLine;
        case 'block':
          return regex.stop;
      }
    })());
  };

  getType = function(single, start) {
    if (single && !start) {
      return 'single';
    } else if (start && !single) {
      return 'block';
    } else {
      if (start.index <= single.index) {
        return 'block';
      } else {
        return 'single';
      }
    }
  };

  countComments = function(code, regex) {
    var myself;
    myself = function(code, idx, res) {
      var cContentIdx, comment, len, lines, match, single, splitAt, start, startIdx, stop, type, _ref, _ref1, _ref2;
      if (code === '') {
        return res;
      }
      start = (_ref = regex.start) != null ? _ref.exec(code) : void 0;
      single = (_ref1 = regex.single) != null ? _ref1.exec(code) : void 0;
      if (!(start || single)) {
        return res;
      }
      type = getType(single, start);
      match = (function() {
        switch (type) {
          case 'single':
            return single;
          case 'block':
            return start;
        }
      })();
      cContentIdx = match.index + match[0].length;
      comment = code.substring(cContentIdx);
      lines = code.substring(0, match.index).split('\n');
      startIdx = lines.length - 1 + idx;
      stop = getStop(comment, type, regex);
      if (!stop) {
        res.error = true;
        return res;
      }
      comment = comment.substring(0, stop.index);
      len = ((_ref2 = comment.match(newLines)) != null ? _ref2.length : void 0) || 0;
      splitAt = cContentIdx + comment.length + stop[0].length;
      code = code.substring(splitAt);
      countMixed(lines, match, idx, startIdx, res);
      res[type].push({
        start: startIdx,
        stop: startIdx + len
      });
      return function() {
        return myself(code, startIdx + len, res);
      };
    };
    return trampoline(myself(code, 0, {
      single: [],
      block: [],
      mixed: []
    }));
  };

  trampoline = function(next) {
    while (typeof next === 'function') {
      next = next();
    }
    return next;
  };

  lineSum = function(comments) {
    var c, d, i, sum, _i, _len, _ref;
    sum = 0;
    for (i = _i = 0, _len = comments.length; _i < _len; i = ++_i) {
      c = comments[i];
      d = (c.stop - c.start) + 1;
      if (((_ref = comments[i + 1]) != null ? _ref.start : void 0) === c.stop) {
        d--;
      }
      sum += d;
    }
    return sum;
  };

  countBlock = function(res) {
    var b, cloc, d, i, s, _i, _j, _len, _len1, _ref, _ref1;
    cloc = 0;
    _ref = res.block;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      b = _ref[i];
      d = (b.stop - b.start) + 1;
      _ref1 = res.single;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        s = _ref1[_j];
        if (!(s.start === b.start || s.start === b.stop)) {
          continue;
        }
        d -= 3;
        break;
      }
      cloc += d;
    }
    return cloc;
  };

  slocModule = function(code, lang) {
    var block, comment, empty, mixed, res, single, source, total, _ref, _ref1;
    if (typeof code !== "string") {
      throw new TypeError("'code' has to be a string");
    }
    total = 1 + ((_ref = code.match(newLines)) != null ? _ref.length : void 0) || 0;
    empty = ((_ref1 = code.match(emptyLines)) != null ? _ref1.length : void 0) || 0;
    res = countComments(code, getCommentExpressions(lang));
    comment = countBlock(res);
    single = lineSum(res.single);
    block = lineSum(res.block);
    mixed = lineSum(res.mixed);
    comment = comment + single;
    source = total - single - block - empty + mixed;
    return {
      total: total,
      source: source,
      comment: comment,
      single: single,
      block: block,
      mixed: mixed,
      empty: empty
    };
  };

  slocModule.extensions = ["coffee", "py", "js", "c", "cc", "cpp", "h", "hpp", "hx", "ino", "erl", "java", "php", "php5", "go", "lua", "scss", "less", "css", "styl", "html"];

  slocModule.keys = keys;

  if ((typeof define !== "undefined" && define !== null ? define.amd : void 0) != null) {
    define(function() {
      return slocModule;
    });
  } else if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = slocModule;
  } else if (typeof window !== "undefined" && window !== null) {
    window.sloc = slocModule;
  }

}).call(this);
